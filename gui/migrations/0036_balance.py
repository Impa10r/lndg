# Generated by Django 4.1.5 on 2023-04-09 14:07

from django.db import migrations, models
import django.utils.timezone
from datetime import datetime, timedelta

def populate_table(apps, schedma_editor):
    payments = apps.get_model('gui', 'payments').objects.values('creation_date', 'fee', 'value').filter(status=2).order_by('creation_date').all()
    invoices = apps.get_model('gui', 'invoices').objects.values('settle_date', 'amt_paid').filter(state=1).order_by('settle_date').all()
    onchain = apps.get_model('gui', 'onchain').objects.values('time_stamp', 'tx_hash', 'fee', 'amount').order_by('time_stamp').all()
    forwards = apps.get_model('gui', 'forwards').objects.values('forward_date', 'fee').order_by('forward_date').all()
    closures = apps.get_model('gui', 'closures').objects.values('closing_costs', 'settled_balance', 'chan_id').all()
    channels = apps.get_model('gui', 'channels').objects.values('funding_txid', 'local_commit', 'capacity').all()
    resolutions = apps.get_model('gui', 'resolutions').objects.values('sweep_txid', 'amount_sat', 'chan_id').all()

    now = datetime.now()
    events_time = sorted([
        *[on['time_stamp'] for on in onchain],
        *[i['settle_date'] for i in invoices],
        *[f['forward_date'] for f in forwards],
        *[p['creation_date'] for p in payments], now, now])
    min_dt = events_time[0]

    timeline = []
    one_hour = timedelta(hours=1)
    costs, on_chain, off_chain, balance_over_time = [0], [0], [0], [0]
    i,j = 0,0
    chan_id_list = []
    while min_dt <= now:
        append = False
        next_dt = events_time[j+1]
        if next_dt < min_dt + one_hour: # min step between events: 1h
            next_dt = min_dt + one_hour

        for tx in onchain.filter(time_stamp__gte=min_dt, time_stamp__lt=next_dt):
            append = True
            costs[i] += tx['fee']
            on_chain[i] += tx['amount']
            for closure in closures.filter(closing_tx=tx['tx_hash']):
                costs[i] += closure['closing_costs']
                if closure['chan_id'] not in chan_id_list:
                    off_chain[i] -= closure['settled_balance']
                    chan_id_list.append(closure['chan_id'])
            for ch in channels.filter(funding_txid=tx['tx_hash']): #open channel
                off_chain[i] += ch['capacity'] - ch['local_commit']
            for resolution in resolutions.filter(sweep_txid=tx['tx_hash']):
                if resolution['chan_id'] not in chan_id_list:
                    costs[i] += closures.filter(chan_id=resolution['chan_id']).first()['closing_costs']
                    off_chain[i] -= resolution['amount_sat']
                    chan_id_list.append(resolution['chan_id'])

        for invoice in invoices.filter(settle_date__gte=min_dt, settle_date__lt=next_dt):
            append = True
            off_chain[i] += invoice['amt_paid']
            
        for forward in forwards.filter(forward_date__gte=min_dt, forward_date__lt=next_dt):
            append = True
            off_chain[i] += forward['fee']
                
        for payment in payments.filter(creation_date__gte=min_dt, creation_date__lt=next_dt):
            append = True
            costs[i] += payment['fee']
            off_chain[i] -= (payment['fee'] + payment['value'])

        balance_over_time[i] = on_chain[i] + off_chain[i]
        if append:
            i += 1
            timeline.append(min_dt)
            costs.append(costs[-1])
            on_chain.append(on_chain[-1])
            off_chain.append(off_chain[-1])
            balance_over_time.append(balance_over_time[-1])
            bal = apps.get_model('gui', 'balance').objects.create(timestamp=timeline[-1],off_chain=off_chain[-1],on_chain=on_chain[-1],costs=costs[-1],total=balance_over_time[-1])
            print("date: "+str(timeline[-1])+", on_chain: "+str(on_chain[-1])+", off_chain: "+str(off_chain[-1])+", costs: "+str(costs[-1])+", total: "+str(balance_over_time[-1]))
            bal.save()
        
        if min_dt == next_dt:
            break
        j += 1
        min_dt = next_dt

def revert_populate_table(apps, schedma_editor):
    pass

class Migration(migrations.Migration):

    dependencies = [
        ('gui', '0035_histfailedhtlc'),
    ]

    operations = [
        migrations.CreateModel(
            name='Balance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('timestamp', models.DateTimeField(default=django.utils.timezone.now)),
                ('on_chain', models.BigIntegerField()),
                ('off_chain', models.BigIntegerField()),
                ('costs', models.BigIntegerField()),
                ('total', models.BigIntegerField()),
            ],
        ),
        migrations.RunPython(populate_table,revert_populate_table),
    ]
